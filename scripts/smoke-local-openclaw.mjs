#!/usr/bin/env node
import net from 'node:net';
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';
import process from 'node:process';
import { spawn } from 'node:child_process';

const HOST = '127.0.0.1';
const API_PORT_START = Number(process.env.SMOKE_API_PORT ?? 18787);
const MOCK_PORT_START = Number(process.env.SMOKE_MOCK_PORT ?? 18135);
const KEEP_TEMP = process.env.SMOKE_KEEP_TEMP === '1';

function log(msg) {
  console.log(`[smoke] ${msg}`);
}

function isPortFree(port, host) {
  return new Promise((resolve) => {
    const srv = net.createServer();
    srv.once('error', () => resolve(false));
    srv.listen(port, host, () => {
      srv.close(() => resolve(true));
    });
  });
}

async function findFreePort(startPort, host, maxTries = 50) {
  for (let p = startPort; p < startPort + maxTries; p++) {
    // eslint-disable-next-line no-await-in-loop
    if (await isPortFree(p, host)) return p;
  }
  throw new Error(`No free port found in range ${startPort}-${startPort + maxTries - 1}`);
}

function run(cmd, args, opts = {}) {
  return spawn(cmd, args, {
    stdio: 'inherit',
    env: { ...process.env, ...(opts.env ?? {}) },
    cwd: opts.cwd,
  });
}

async function waitForHttp(url, timeoutMs = 15000) {
  const started = Date.now();
  let lastErr = null;
  while (Date.now() - started < timeoutMs) {
    try {
      const res = await fetch(url);
      if (res.ok) return;
      lastErr = new Error(`HTTP ${res.status}`);
    } catch (err) {
      lastErr = err;
    }
    await new Promise((r) => setTimeout(r, 200));
  }
  throw new Error(`Timeout waiting for ${url}: ${String(lastErr ?? 'unknown error')}`);
}

async function apiRequest(baseUrl, method, endpoint, body) {
  const res = await fetch(`${baseUrl}${endpoint}`, {
    method,
    headers: {
      'content-type': 'application/json',
    },
    body: body === undefined ? undefined : JSON.stringify(body),
  });
  const raw = await res.text();
  let json = null;
  try {
    json = raw ? JSON.parse(raw) : null;
  } catch {
    json = raw;
  }
  if (!res.ok) {
    throw new Error(`${method} ${endpoint} failed: HTTP ${res.status} ${raw}`);
  }
  return json;
}

async function main() {
  const repoRoot = process.cwd();
  const apiPort = await findFreePort(API_PORT_START, HOST);
  const mockPort = await findFreePort(MOCK_PORT_START, HOST);
  const baseUrl = `http://${HOST}:${apiPort}`;
  const mockUrl = `http://${HOST}:${mockPort}/v1/chat/completions`;

  const tempRoot = fs.mkdtempSync(path.join(os.tmpdir(), 'dzzen-smoke-'));
  const dbPath = path.join(tempRoot, 'dzzenos.db');
  const workspaceDir = path.join(tempRoot, 'workspace');
  const authPath = path.join(tempRoot, 'auth.json');

  log(`temp root: ${tempRoot}`);
  log(`starting mock OpenResponses: ${mockUrl}`);
  const mock = run('node', ['scripts/mock-openresponses.mjs', '--host', HOST, '--port', String(mockPort)], {
    cwd: repoRoot,
  });

  log(`starting API at ${baseUrl}`);
  const api = run(
    'node',
    ['--experimental-strip-types', 'skills/dzzenos/api/server.ts', '--host', HOST, '--port', String(apiPort), '--db', dbPath],
    {
      cwd: repoRoot,
      env: {
        OPENRESPONSES_URL: mockUrl,
        DZZENOS_OPENRESPONSES_MODEL: 'openclaw:main',
        DZZENOS_WORKSPACE_DIR: workspaceDir,
        DZZENOS_AUTH_FILE: authPath,
      },
    }
  );

  const cleanup = () => {
    if (!mock.killed) mock.kill('SIGTERM');
    if (!api.killed) api.kill('SIGTERM');
  };

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);

  try {
    await waitForHttp(`http://${HOST}:${mockPort}/healthz`, 15000);
    await waitForHttp(`${baseUrl}/boards`, 25000);
    log('services are up');

    const boards = await apiRequest(baseUrl, 'GET', '/boards');
    if (!Array.isArray(boards) || boards.length === 0) throw new Error('No boards in seed data');
    const boardId = String(boards[0].id);
    log(`board: ${boardId}`);

    const task = await apiRequest(baseUrl, 'POST', '/tasks', {
      boardId,
      title: 'Smoke: verify local mock flow',
      description: 'Generated by smoke-local-openclaw.mjs',
    });
    const taskId = String(task.id);
    log(`task created: ${taskId}`);

    const installedSkill = await apiRequest(baseUrl, 'POST', '/marketplace/skills/core.github/install');
    if (!installedSkill?.slug) throw new Error('Skill install did not return slug');
    log(`skill installed: ${installedSkill.slug}`);

    const installedAgent = await apiRequest(baseUrl, 'POST', '/marketplace/agents/core.general/install');
    if (!installedAgent?.id) throw new Error('Agent install did not return id');
    const agentId = String(installedAgent.id);
    log(`agent installed: ${agentId}`);

    await apiRequest(baseUrl, 'PATCH', `/agents/${encodeURIComponent(agentId)}`, {
      skills_json: ['github'],
    });
    log('agent patched with installed skill');

    const runResult = await apiRequest(baseUrl, 'POST', `/tasks/${encodeURIComponent(taskId)}/run`, {
      mode: 'plan',
      agentId,
    });
    if (!runResult?.runId) throw new Error('Run endpoint did not return runId');
    log(`plan run succeeded: ${runResult.runId}`);

    const chat = await apiRequest(baseUrl, 'POST', `/tasks/${encodeURIComponent(taskId)}/chat`, {
      text: 'Post a short status update',
      agentId,
    });
    if (!chat?.reply || String(chat.reply).toLowerCase().includes('openresponses error')) {
      throw new Error(`Chat failed: ${JSON.stringify(chat)}`);
    }
    log('chat reply received');

    const checklist = await apiRequest(baseUrl, 'GET', `/tasks/${encodeURIComponent(taskId)}/checklist`);
    if (!Array.isArray(checklist) || checklist.length === 0) {
      throw new Error('Checklist not generated by plan run');
    }
    log(`checklist items: ${checklist.length}`);

    const runs = await apiRequest(baseUrl, 'GET', `/tasks/${encodeURIComponent(taskId)}/runs`);
    if (!Array.isArray(runs) || runs.length === 0) {
      throw new Error('No runs found for smoke task');
    }
    log(`runs: ${runs.length}`);

    log('PASS');
  } finally {
    cleanup();
    if (!KEEP_TEMP) {
      fs.rmSync(tempRoot, { recursive: true, force: true });
    } else {
      log(`temp data preserved at ${tempRoot}`);
    }
  }
}

main().catch((err) => {
  console.error('[smoke] FAIL:', err?.stack ?? String(err));
  process.exit(1);
});
